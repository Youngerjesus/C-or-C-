
/*
좌상단에서 우하단까지 이동ㅎ는데 가장 합이 작도록 하는 경로를 말한다 .
그 담칸 까지가는건 최소로 가는걸 알 수 있는데 그담 담 칸까지를 알기는
힘들지 즉 모든 칸의 값을 게산한담에 합쳐야하는거지
그걸 담을 메모리와 space를 확보를 해얗아낟. 
어떻게 값을 넣어주면서 가면될까 .
BFS() 방법으로 한ㅂ

그래프 다익스트라 알고리즘  
피보나치수열고 ㅏ

슌환식을 세우고 해결해나가는 것 
(i,j) 있다면 
push를 어떤식으로 해놓는게 나을까 라는걸 생가갷봐야지 
각 경로에대해서 
인덱스도 같이보낸다면?  i를 넣어주고 i를 더한다 내가 넣어줘야하는 index를
구분 하기가 어렵다 . 이전값이 어딨는지만 알고 그 다음 값
n개의 stack을 만드는거랑 같은 문제인ㄹ거같은데 
이건 stack의 개수가 어케하면될까 나중 index는 push를 하면되잖아 
top과 i를 가지고 있으면되는거아님 ?
이런경우 근데 i와 top이 같아지지않나 ?
i는 보내주고 top은 계속 가지고 있으면서 ++해주면 
현재시점에서 멈추는거지 i는 

계속 최선에 최선으을선택 

10  20  100 

50  1  1000 

5
이런경우에는 어떻게할건데 10  50 5 가 제일 낫잖아 

0 0 0 0 0
0 0 0 0 0
0 0 0 0 1
0 0 0 20 10
0 0 100 5 0 

min()
아 계속 재귀가 더해지는구나.. 동적계획법에서 이게 줫나중요하네 .
매번 그 경우를 더한다!!! 갈  수 있는 최소거리를 더한다!!! 이걸로 결정되는게아니네
 
*/


// 행렬 경로 문제 
// Recursive Algorithm 
// 여기서 bottom up 과 top down의 차이느 
int mat(int i, int j) {
    if( i == 1 && j == 1 ) return m[i][j];

    else if ( i == 1) return mat(1, j-1) + m[i][j]; 

    else if ( j == 1 ) return mat(i-1 ,1) + m[i][j]; 

    else return Math.min(mat(i-1, j), mat(i,j-1) ) + m[i][j]; 
}

/*
왜 벽을 타야하는게 있는지도 이해가안감  외길이니까 그런거라고 
top down으로
bottom - u p으로는 topdown 개념이 적용이안되지 
fibonaccci   
*/

int mat2(int i, int j) {
     //각 지점까지의 최소거리를 말하는거네 
    if(L[i][j] != - 1) return L[i][j]; 
    else if( i == 1 ) L[i][j] + mat[i][j]; 
    else if ( j ==  1) L[i][j] + mat[i][j]; 
    else L[i][j] = Math.min(mat(i-1,j), mat(i,j-1   ) + m[i][j]; 
}
// Bottom up 이아닌 memorization을 말하는거지 여기서는 
/*
bottom up 방식으로 계산이 된다라는건가? 
방향성을 제시해주면되는거구나 
비교해서 더한다 이런생각만하지말고 
기본 생각자체가 잘못됬네 
방학때 방 비우시거나 거의 안 사시는분 있나여??? 
보증금은 빼고 월세랑 관리비(전기세 가스비)만 부담할테니 저한테 방  
맡기실분 있나여 010 - 4115 6894로 연락주세요~~~

*/

int mat3(int i, int j) {
    for(int i=1; i<=n ; i++) {
        for (int j=1; j<=n; j++) {
            if(i==1 && j== 1)
                L[i][j] = m[i][j]; // 이건어짜피 한번만 검토하면되는거니까 첨 시작할떄해줘도되늗네 
            else if (i == 1) L[i][j] = m[i][j] + L[i][j-1]; //이런경우 이전걸 더하는게 규칙상으론맞지만 L         
            else if (j == 1) L[i][j] = m[i][j] + L[i-1][j]; 
            else L[i][j] = Math.min(mat(i-1,j), mat(i,j-1) + m[i][j]; 
        }
    }
    return L[n][n]; //아니봐ㅏ바 ... 
}